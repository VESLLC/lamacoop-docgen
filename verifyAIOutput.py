# lamacoop-docgen - Python scripts for automating code and docs with LLMs
# Copyright (C) 2025 VES LLC
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# For inquiries, please contact by email:
#   info@ves.solutions
#
# Or if you prefer, by paper mail:
#   VES LLC
#   6180 Guardian Gtwy, Ste 102
#   Aberdeen Proving Ground, MD 21005

# Standard libraries
import sys
import subprocess
import re

def getFunctionName(functionDeclaration:str) -> str:
    '''
    This function strips specifically the name from the function dclaration
    We use it lower to produce a dictionary of function names and their comment 
    files
    i.e:
    Function Definition:
        static inline void *alloc_tramp(unsigned long size)

    Function Name:
        alloc_tramp
    '''
    
    specialCharacters: str = "*&@"
    codeArguments: list = re.split(r'[\(\)]+', functionDeclaration)
    functionName: str = codeArguments[0].split(" ")[-1]
    if any(c in specialCharacters for c in functionName):
        functionName = functionName[1:]
    functionName = functionName.split("\n")[-1]
    return functionName

'''
Breaking up the code by ()
This uses the regex split which uses a regex statement, r'[\(\)]+' to 
split on either ( or ), declared as \( and \) respectively
'''

def checkFunctionHeader(functionHeader : str, generatedName : str) -> bool:
    functionName = getFunctionName(functionHeader)


    if (functionName not in generatedName):
    # There exsists a comment for the functions general use
        '''
        print("Function documentation needs added to the first line")
        '''
        print("Function Declaration: ", functionName,"Comment: ",
                generatedName)
        return False
        
    return True

# Check for argument comments
def ArgumentComments(functionArguments: list, commentLines: list) -> bool:
    i = 2
    specialCharacters: str = "*&@"
    argument: str = ""
    hasArgumentComments = True

    for argument in functionArguments:
        argument: list = argument.split(" ")
        argument: str = argument[len(argument)-1] 
        # print("Argument: ", argument, i, "CommentLine: ", commentLines[i])

        '''
        Acts to check if there are any matching characters between 
        specialCharacters and the argument string, trying to remove markers
        from function arguments
        '''
        if any(c in specialCharacters for c in argument):
            argument = argument[1:]
            if("@" + argument not in commentLines[i]):
                print("Missing argument documentation: ", i - 1)  
                print("Argument: ", argument, "CommentLine: ", commentLines[i])
                hasArgumentComments = False
        i = i + 1
    return hasArgumentComments

# Check if there is a reasonable amount of lines of text expressing the 
# expectations, this can be adjusted
def CommentLength(functionExpectations: list, 
                      functionArguments: list) -> bool:
    if(len(functionExpectations) < (len(functionArguments)*2)):
        return False
    return True

def checkCommentFormatting(commentHead : str, commentTail : str) -> bool:
    """
        Verifies that the generated comment opens and closes like astandard C block comment

        This check verifies that comments generated by the LLM properly open and close (i.e. 
        begins and ends with /* */). Occasionally, the AI will forget to add these brackets,
        which may result in one or more functions being comment out. 

        @param commentHead: Expects string of two characters, top slice of comment block
        @param commentTail: Expects string of two characters, bottom slice of comment block
        @return: bool 

        # TODO Add some functionality to fix this mistake if this fails
    """
    return (commentHead == "/*" and commentTail == "*/")
